// Timing test for four 0..MAXSPRITES-1 access loops,
// fwd->back->fwd->back.
// Results with a LTO=1 RELEASE=1 C-CON build on x86: 42 ms for N=10.
// (Compare with Lunatic results in test.elua)

define N 10
gamevar n 0 0
gamevar i 0 0
gamevar t 0 0
gamevar t2 0 0
define MAXSPRITES 16384
define MAXSPRM1 16383  // MAXSPRITES-1

onevent EVENT_ENTERLEVEL
    getticks t

    setvar n 0
    whilevarn n N
    {
        setvar i 0
        whilevarvarn i MAXSPRITES
        {
            setactor[i].blend 1
            addvar i 1
        }

        setvar i MAXSPRM1
        whilevarvarn i -1
        {
            setactor[i].shade 1
            subvar i 1
        }

        setvar i 0
        whilevarvarn i MAXSPRITES
        {
            setactor[i].xoffset 0
            addvar i 1
        }

        setvar i MAXSPRM1
        whilevarvarn i -1
        {
            setactor[i].yoffset 0
            subvar i 1
        }

        addvar n 1
    }

    getticks t2
    subvarvar t2 t

    // qsprintf test
    redefinequote 116 0..MAXSPITES-1
    redefinequote 117 in total

    redefinequote 114 %d x four %s iterations took %d ms %s
    qsprintf 115 /*<-*/ 114 /*args:*/ n 116 t2 117

    echo 115
endevent


////////// Periodically alpha-faded liztroop //////////

gamevar alpha 0 0
gamevar tmp 0 0

onevent EVENT_GAME  // XXX: better: in EVENT_EGS + EVENT_LOADACTOR
    ifactor LIZTROOP
    {
        getactor[THISACTOR].mdflags tmp
        orvar tmp 16
        setactor[THISACTOR].mdflags tmp
    }
endevent

define NUMALPHATABS 128
define C1 0  //must be log2(128/NUMALPHATABS)
define C2 257  // must be 2*NUMALPHATABS+1

define ALPHA_TABS_BY_EDUKE32 1  // assume alpha->blend handling by EDuke32

onevent EVENT_ANIMATESPRITES
    setvarvar tmp totalclock
    shiftvarl tmp 2

    sin alpha tmp   // alpha is now in [-2^14 .. 2^14]
    shiftvarr alpha 7  // [-2^7 .. 2^7]
    addvar alpha 128  // [0 .. 256]
    shiftvarr alpha C1  // [0 .. 2*NUMALPHATABS]

    ifvarn ALPHA_TABS_BY_EDUKE32 0
    {
        subvar alpha 1
        ifvarl alpha 0 setvar alpha 0
        setactor[THISACTOR].alpha alpha

        break
    }

    ifvare alpha 0
    {
        // clear translucent bits, 0xfdfe == 0xffff-(1+512)
        gettspr[THISACTOR].tsprcstat tmp
        andvar tmp 0xfdfe
        settspr[THISACTOR].tsprcstat tmp
    }
    else
    {
        gettspr[THISACTOR].tsprcstat tmp
        orvar tmp 2
        settspr[THISACTOR].tsprcstat tmp

        // Assume blending tables [1 .. NUMALPHATABS] are installed, like
        // generated by shadexfog.lua:create_alpha_trans(1, NUMALPHATABS).
        ifvarg alpha NUMALPHATABS
        {
            setvarvar tmp C2
            subvarvar tmp alpha
            setvarvar alpha tmp

            // Set "reverse translucent" cstat bit
            gettspr[THISACTOR].tsprcstat tmp
            orvar tmp 512
            settspr[THISACTOR].tsprcstat tmp
        }
        else
        {
            // Clear cstat bit 512
            gettspr[THISACTOR].tsprcstat tmp
            andvar tmp 0xfdff
            settspr[THISACTOR].tsprcstat tmp
        }

        settspr[THISACTOR].tsprblend alpha
    }
endevent
